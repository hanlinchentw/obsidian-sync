### Thinkingï¼š
1. visited: set string
2. eight different operation: two for each position
3. dfs return count

### Solution:

```
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
	    unordered_set<string> dead(deadends.begin(), deadends.end());
        unordered_set<string> visited;

		queue<string> q;
		q.push("0000");

		int changes = 0;
		while (!q.empty()) {
			int size = q.size();
			while (size--) {
				auto curr = q.front(); q.pop();
				if (curr == target) return changes;
				if (dead.count(curr) || visited.count(curr)) continue;
				visited.insert(curr);

				int first = curr[0] - '0';
				int second = curr[1] - '0';
				int third = curr[2] - '0';
				int four = curr[3] - '0';

				string copy = curr;
				copy[0] = first == 9 ? '0' : first + 1 + '0';
				q.push(copy);
				copy = curr;
				copy[0] = first == 0 ? '9' : first - 1 + '0';
				q.push(copy);
				copy = curr;
				copy[1] = second == 9 ? '0' : second + 1 + '0';
				q.push(copy);
				copy = curr;
				copy[1] = second == 0 ? '9' : second - 1 + '0';
				q.push(copy);
				copy = curr
				copy[2] = third == 9 ? '0' : third + 1 + '0';
				q.push(copy);
				copy = curr;
				copy[2] = third == 0 ? '9' : third - 1 + '0';
				q.push(copy);
				copy = curr
				copy[3] = four == 9 ? '0' : four + 1 + '0';
				q.push(copy);
				copy = curr
				copy[3] = four == 0 ? '9' : four - 1 + '0';
				q.push(copy);
			}
			changes++;
		}
		return -1;
    }
};
```

review: