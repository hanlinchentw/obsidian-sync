### Thinkingï¼š

### Solution:

```
class Solution {
public:
	vector<vector<int>> verticalTraversal(TreeNode* root) {
		vector<pair<TreeNode*, pair<int, int>> coors;
		traversal(root, {0, 0}, coors);
		sort(coors.begin(), coors.end, [](const pair<TreeNode*, pair<int, int>& left, const pair<TreeNode*, pair<int, int>& right){
			int leftRow = left.second.first;
			int rightRow = left.second.first;
			int leftCol = left.second.second;
			int rightCol = right.second.second;
			return leftRow < rightRow && leftCol < rightCol;
		});
		vector<vector<int>> ans;
		int currCol = INT_MAX;
		for (auto coor : coors) {
			TreeNode* node = coor.first;
			pair<int, int> point = coor.second;
			if (point.second != currCol) {
				currCol = point.second;
				ans.push_back({node->val});
			} else {
				ans[ans.size() - 1].push_back(node->val);
			}
		}
		return ans;
	}

	void traversal(TreeNode* node, pair<int, int> point, vector<pair<TreeNode*, pair<int, int>>& coors) {
		if (!node) return NULL;
		int row = point.first;
		int col = point.second;
		coors.push({node, point);
		traversal(node->left, {row+1, col-1}, coors);
		traversal(node->right, {row+1, col+1}, coors);
	}
};
```

review: