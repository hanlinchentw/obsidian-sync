### Thinkingï¼š


### Solution:

```
class Solution {
public:
	int openLock(vector<string>& deadends, string target) {
		unordered_set<string> visited;
		string initial = "0000";
		queue<pair<int, string>> que;
		que.push({0, initial});
		
		while (!que.empty()) {
			auto front = que.front(); que.pop();
			
			int changes = front.first;
			string comb = front.second;
			if (comb == target)
				return changes;
			if (
				find(deadends.begin(), deadends.end(), comb) != deadends.end() &&
				visited.count(comb)
			)
				continue;

			visited.insert(comb);

			int first_char = comb[0] - '0';
			int second_char = comb[1] - '0';
			int third_char = comb[2] - '0';
			int four_char = comb[3] - '0';

			string copy = comb;
			copy[0] = static_cast<char>(first_char == 9 ? 0 : first_char + 1);
			que.push({changes+1, copy});
			copy = comb;
			copy[0] = static_cast<char>(first_char == 0 ? 9 : first_char - 1);
			que.push({changes+1, copy});

			copy = comb;
			copy[1] = static_cast<char>(second_char == 9 ? 0 : second_char + 1);
			que.push({changes+1, copy});
			copy = comb;
			copy[1] = static_cast<char>(second_char == 0 ? 9 : second_char - 1);
			que.push({changes+1, copy});

			copy = comb;
			copy[2] = static_cast<char>(third_char == 9 ? 0 : third_char + 1);
			que.push({changes+1, copy});
			copy = comb;
			copy[2] = static_cast<char>(third_char == 0 ? 9 : third_char - 1);
			que.push({changes+1, copy});

			copy = comb;
			copy[3] = static_cast<char>(four_char == 9 ? 0 : four_char + 1);
			que.push({changes+1, copy});
			copy = comb;
			copy[3] = static_cast<char>(four_char == 0 ? 9 : four_char - 1);
			que.push({changes+1, copy});
		}
		return 0;
	}
};
```

review: