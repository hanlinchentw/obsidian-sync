### Thinkingï¼š
1. loop entire mat first, find all 1 and mark them as INT_MAX
2. loop again, if num is INT_MAX, dfs, return min(top, left, bottom, right) + 1

### Solution:

```
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
	    int n = mat.size(); m = mat[0].size();
        for (int i = 0; i < n; i++) {
	        for (int j = 0; j < m; j++) {
		        if (mat[i]][j] == 1)
			        mat[i][j] = INT_MAX;
	        }
        }
		set<pair<int, int>> visited;
		for (int i = 0; i < n; i++) {
	        for (int j = 0; j < m; j++) {
		        if (mat[i]][j] == INT_MAX)
			        dfs(mat, i, j);
	        }
        }
    }

	int dfs(vector<vector<int>>& mat, int i, int j, set<pair<int, int>>& visited) {
		if (mat[i][j] != INT_MAX || mat[i][j] == 0) return mat[i][j] + 1;
		int top = dfs(mat, i-1, j);
		int left = dfs(mat, i, j-1);
		int bottom = dfs(mat, i+1, j);
		int right = dfs(mat, i, j+1);
		mat[i][j] = min(min(top, left), min(bottom, right));
		return mat[i][j] + 1;
	}
};
```

review: