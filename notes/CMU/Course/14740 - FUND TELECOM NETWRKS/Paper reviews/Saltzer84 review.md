# End-To-End Arguments in System Design

#### Summary:
The end-to-end argument, a principle for placing functions in layered systems, shows that correctness can be ensured by end-to-end checks and retries, while low-level implementations serve mainly for performance enhancements.
#### Important points
1. Low-level mechanisms cannot guarantee correctness, but they can improve performance by reducing error frequency. True correctness requires end-to-end checks and retries at the application level.
	<u>_Justification_:</u> This is important because the file transfer example shows that many threats exist at different layers, including disk, memory, software, network, and crashes. While low-level mechanisms help, they cannot cover all threats and require significant effort from engineers. An end-to-end checksum and retry provide correctness at minimal cost. In addition, since low-level systems are shared across applications, forcing certain features there can burden applications that do not need them. Moreover, issues such as duplicate suppression and encryption follow the same principle as data integrity: they are better implemented at the application layer, since only the application has sufficient context to handle them effectively. However, if low-level functions are unreliable or the error rate is not negligible, end-to-end retries may loop excessively, so low-level mechanisms can still be useful as performance enhancements.
2. The "true" ends vary with the application. What’s useful for one case (e.g., live conversation) may harm another (e.g., recorded messages). 
	<u>_Justification_:</u>  This is important because it prevents misapplication of the principle. It shows that the argument is a guideline rather than a rigid rule, forcing designers to consider the application context, such as latency versus accuracy, rather than blindly enforcing reliability at one layer. It encourages nuanced engineering decisions that fit the actual end requirements instead of applying a one-size-fits-all solution.
3. History shows repeated rediscovery, indicating that end-to-end arguments is a general principle. It keeps reappearing in different domains: networking, file storage, banking audits, OS kernels, even RISC architecture.
	<u>_Justification_:</u> This is important because it demonstrates the generality of the principle: correctness belongs at the endpoints in any layered system. Historical failures, such as corrupted tape systems or network gateways, show the cost of ignoring it. It also provides a unifying way to think across fields — whether in networking, operating systems, or storage, the same principle applies. Finally, it reinforces that the end-to-end argument is not just theoretical but solves practical, recurring problems in real-world systems.
#### Comments/Questions
1. 
#### Citation
	